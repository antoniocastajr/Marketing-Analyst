# PROJECT: Data Analyst Agent
# AUTHOR: Antonio Castañares Rodríguez
# -----------------------

# DESCRIPTION: This file generates and saves relevant visualizations available for our Marketing Analyst.

import os 
import logging
import duckdb
import plotly.express as px

# --------------------------------------LOGGING--------------------------------------------
# Logging configuration (print time, name, level and message using the terminal)
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# Suppress the httpx library logs to avoid cluttering the output
logging.getLogger("httpx").setLevel(logging.WARNING)
LOGGER = logging.getLogger(__name__)

# --------------------------------------PLOT GENERATOR CLASS---------------------------------

class PlotGenerator:
    """Generates and saves plots for marketing analysis."""

    _instance = None
    _plots = [
             {
                "title": "Customer Segment Analysis",
                "description": "Bar plot that visualizes customer segments based on key metrics.",
                "path": "plots/segment_analysis.json"
             },{
                 'title': 'Customer Segment Distribution',
                 'description': 'Pie chart showing the distribution of customers across different segments.',
                 'path': 'plots/segment_distribution.json'
             },{
                 'title': 'Revenue by Customer Segment',
                 'description': 'Bar chart displaying revenue generated by each customer segment.',
                 'path': 'plots/revenue_by_segment.json'
             },{
                 'title': 'Best Selling Products by Revenue',
                 'description': 'Bar chart highlighting the top-selling products in the dataset by revenue.',
                 'path': 'plots/best_selling_products.json'
             },{
                 'title': 'Best Countries by Revenue',
                 'description': 'Bar chart showing the top countries by revenue.',
                 'path': 'plots/best_countries_by_revenue.json'
             },{
                'title': 'Best Countries by Number of Customers',
                'description': 'Bar chart showing the top countries by number of customers.',
                'path': 'plots/best_countries_by_customers.json'
            },{
                'title': 'Best Products by Number of Purchases',
                'description': 'Bar chart highlighting the top-selling products in the dataset by number of purchases.',
                'path': 'plots/best_products_by_purchases.json'
             },{
                'title': 'Best Users by Revenue',
                'description': 'Bar chart highlighting the top users in the dataset by revenue.',
                'path': 'plots/best_users_by_revenue.json'
             },{
                'title': 'Best Users by Number of Purchases',
                'description': 'Bar chart highlighting the top users in the dataset by number of purchases.',
                'path': 'plots/best_users_by_purchases.json'
             },{
                'title': 'Correlation Heatmap of Key Metrics',
                'description': 'Heatmap showing the correlation between p1, purchase_frequency and average_order_value.',
                'path': 'plots/correlation_heatmap.json'
             },{
                'title': 'Price vs. Purchase Count',
                'description': 'Scatter plot showing the relationship between product price and number of purchases.',
                'path': 'plots/price_vs_purchase_count.json'
             },{
                'title': 'Email Provider Distribution',
                'description': 'Bar chart showing the top email providers by number of customers.',
                'path': 'plots/email_provider_distribution.json'
             } 
    ]

    def __new__(cls):
        """Ensure only one instance of PlotGenerator exists."""
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def get_plots(self) -> list:
        """Public method to get all plots metadata."""
        return self._plots.copy()
    
    def get_available_plots(self) -> list:
        """Get list of plots that exist on disk.
        
        Returns:
            list: Plots with their metadata that have been generated.
        """
        available = []
        for plot in self._plots:
            if os.path.exists(plot['path']):
                plot_info = plot.copy()
                plot_info['available'] = True
                available.append(plot_info)
        return available
    
    def get_plot_by_title(self, title: str) -> dict:
        """Get a specific plot by its title.
        
        Args:
            title: The title of the plot to retrieve.
            
        Returns:
            dict: Plot metadata or None if not found.
        """
        for plot in self._plots:
            if plot['title'] == title:
                return plot.copy()
        return None
    
    def check_plot_exist(self, path) -> bool:
        """Check if a specific plot exists."""
        if not os.path.exists(path):
            return False
        return True

    def generate_plots(self,dataManager):
        """Generate and save all plots."""
        # Create plots directory if it doesn't exist
        os.makedirs('plots', exist_ok=True)

        for plot in self._plots:
            # Generate each plot based on its title or description
            if plot['title'] == "Customer Segment Analysis" and not self.check_plot_exist(plot['path']):
                fig = self._segment_analysis_plot(dataManager)
            elif plot['title'] == "Customer Segment Distribution" and not self.check_plot_exist(plot['path']):
                fig = self._segment_distribution_plot(dataManager)
            elif plot['title'] == "Revenue by Customer Segment" and not self.check_plot_exist(plot['path']):
                fig = self._revenue_by_segment_plot(dataManager)
            elif plot['title'] == "Best Selling Products by Revenue" and not self.check_plot_exist(plot['path']):
                fig = self._best_selling_products_plot(dataManager)
            elif plot['title'] == "Best Countries by Revenue" and not self.check_plot_exist(plot['path']):
                fig = self._best_countries_by_revenue_plot(dataManager)
            elif plot['title'] == "Best Countries by Number of Customers" and not self.check_plot_exist(plot['path']):
                fig = self._best_countries_by_customers_plot(dataManager)
            elif plot['title'] == "Best Products by Number of Purchases" and not self.check_plot_exist(plot['path']):
                fig = self._best_selling_products_plot(dataManager)
            elif plot['title'] == "Best Users by Revenue" and not self.check_plot_exist(plot['path']):
                fig = self._best_users_by_revenue_plot(dataManager)
            elif plot['title'] == "Best Users by Number of Purchases" and not self.check_plot_exist(plot['path']):
                fig = self._best_users_by_purchases_plot(dataManager)
            elif plot['title'] == "Correlation Heatmap of Key Metrics" and not self.check_plot_exist(plot['path']):
                fig = self._correlation_heatmap_plot(dataManager)
            elif plot['title'] == "Email Provider Distribution" and not self.check_plot_exist(plot['path']):
                fig = self._email_provider_plot(dataManager)
            else:
                continue
            
            # Save the plot to the specified path
            # Save to file
            try:
                with open(plot['path'], 'w') as f:
                    f.write(fig.to_json())
            except Exception as e:
                print(f"Error saving plot: {e}")
        
    def _segment_analysis_plot(self, dataManager):
        """Generate Customer Segment Analysis plot."""
    
        try:
            leads_scored = dataManager.leads_scored
            transactions = dataManager.transactions
            # Select only needed columns for analysis
            leads_scored = leads_scored[['user_email', 'p1', 'member_rating', 'customer_segment']]
            transactions = transactions[['user_email', 'purchased_at']]
        except Exception as e:
            LOGGER.error(f"Error loading data: {e}")
            raise

        # Calculate transaction_frequency (group by user_email and count transactions)
        purchase_frequency = transactions.groupby('user_email').size().reset_index(name='purchase_frequency')
        LOGGER.info(f"Transaction frequency calculated. Mean frequency: {purchase_frequency['purchase_frequency'].mean():.2f}")

        # Combines customer profiles with their purchase activity, keeping all customers even if they never purchased anything.
        df_analysis = leads_scored.merge(purchase_frequency, on='user_email', how='left')
        LOGGER.info(f"Features merged. Customer data shape: {df_analysis.shape}")

        # Fill missing values
        df_analysis['purchase_frequency'] = df_analysis['purchase_frequency'].fillna(0)

        # Create summary statistics for each customer segment and rename user_email to customer_count
        df_summary = df_analysis.groupby('customer_segment').agg({
            'p1': 'mean',                                                                                                           # Use mean for lead score                        
            'member_rating': 'mean',                                                                                                # Use mean for member rating                                                         
            'purchase_frequency': 'mean',                                                                                           # Use mean for purchase frequency      
            'user_email': 'count'                                                                                                   # Count customers in each segment   
        }).rename(columns={'user_email': 'customer_count'}).reset_index()

        # Round statistics for better readability
        df_summary['avg_p1'] = df_summary['p1'].round(3)
        df_summary['avg_member_rating'] = df_summary['member_rating'].round(2)
        df_summary['avg_purchase_frequency'] = df_summary['purchase_frequency'].round(2)

        # Define segment labels
        segment_labels = {
            '0': 'Segment 0',                # Low engagement
            '1': 'Segment 1',                # Occasional engagement
            '2': 'Segment 2',                # Regular engagement
            '3': 'Segment 3',                # Strong engagement
            '4': 'Segment 4'                 # Maximum engagement
        }
            
        # Apply segment labels to the summary DataFrame
        df_summary['segment_name'] = df_summary['customer_segment'].astype(str).map(segment_labels).fillna(df_summary['customer_segment'].astype(str))

        # Create Plotly bar chart
        df_viz = df_summary.melt(id_vars=['segment_name'],
                                value_vars=['avg_p1', 'avg_member_rating', 'avg_purchase_frequency'],
                                var_name='Metric',
                                value_name='Value')
        
        fig = px.bar(
            df_viz,
            x='segment_name',
            y='Value',
            color='Metric',
            barmode='group',
            title='Segment Analysis: Lead Score, Member Rating, Purchase Frequency',
            labels={'segment_name': 'Customer Segment', 'Value': 'Average Value', 'Metric': 'Metric'}
        )

        return fig

    def _segment_distribution_plot(self, dataManager):  
        """Generate Customer Segment Distribution plot."""
        leads_scored = dataManager.leads_scored

        query = """
            SELECT 
                customer_segment,
                COUNT(*) AS customer_count
            FROM leads_scored
            GROUP BY customer_segment
        """

        result = duckdb.query(query).to_df()
        result['customer_segment'] = result['customer_segment'].map(lambda x: f'Segment {x}')
        fig = px.pie(
            result,
            names='customer_segment',
            values='customer_count',
            title='Customer Segment Distribution',
            labels={'customer_segment': 'Customer Segment', 'customer_count': 'Number of Customers'},
            color='customer_segment',
            color_discrete_sequence=[ '#FFA07A','#FF6B6B','#4ECDC4','#45B7D1','#98D8C8','#FF6B6B' ]
        )

        # Format the text on pie slices to show percentage and currency
        fig.update_traces(
            texttemplate='%{label}<br>%{percent}<br>$%{value:,.0f}',
            textposition='inside',
            textfont_size=12
        )
        
        return fig

    def _revenue_by_segment_plot(self, dataManager):
        """Generate Revenue by Customer Segment plot."""
        leads_scored = dataManager.leads_scored
        transactions = dataManager.transactions
        products = dataManager.products

        query = """
            SELECT 
                l.customer_segment,
                SUM(p.suggested_price) AS total_revenue
            FROM leads_scored l
            LEFT JOIN transactions t ON l.user_email = t.user_email
            LEFT JOIN products p ON t.product_id = p.product_id
            GROUP BY l.customer_segment
            ORDER BY l.customer_segment
        """

        result = duckdb.query(query).to_df()
        result['customer_segment'] = result['customer_segment'].map(lambda x: f'Segment {x}')
         
        fig = px.bar(
            result,
            x='customer_segment',
            y='total_revenue',
            title='Revenue by Customer Segment',
            labels={'customer_segment': 'Customer Segment', 'total_revenue': 'Total Revenue ($)'},
            color='customer_segment',
            color_discrete_sequence=['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'],
            text='total_revenue'
        )
        
        # Format the text on bars to show currency
        fig.update_traces(texttemplate='$%{text:,.0f}', textposition='outside')
        
        return fig

    def _best_selling_products_plot(self, dataManager):
        """Generate Best Selling Products by Revenue plot."""
        transactions = dataManager.transactions
        products = dataManager.products

        query = """
            SELECT 
                p.product_id,
                p.description AS product_description,
                SUM(p.suggested_price) AS total_revenue
            FROM transactions t
            INNER JOIN products p ON t.product_id = p.product_id
            GROUP BY p.product_id, p.description
            ORDER BY total_revenue DESC
            LIMIT 5
        """

        result = duckdb.query(query).to_df()
        result['product_id'] = result['product_id'].map(lambda x: f'Product {int(x)}')
        result['total_revenue'] = result['total_revenue'].round(2)

        fig = px.bar(
            result,
            x='product_id',
            y='total_revenue',
            title='Top 5 Best Selling Products by Revenue',
            labels={'product_id': 'Product', 'total_revenue': 'Total Revenue ($)', 'product_description': 'Description'},
            text='total_revenue',
            color='product_id',  
            color_discrete_sequence=['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'],
            hover_data=['product_description']  # Show description on hover
        )
        
        # Format text on bars
        fig.update_traces(texttemplate='$%{text:,.0f}', textposition='outside')
        
        return fig

    def _best_countries_by_revenue_plot(self, dataManager):
        """Generate Best Countries by Revenue plot."""
        leads = dataManager.leads_scored
        transactions = dataManager.transactions
        products = dataManager.products

        query = """
            SELECT 
                t.charge_country AS country,
                SUM(p.suggested_price) AS total_revenue
            FROM transactions t
            INNER JOIN products p ON t.product_id = p.product_id
            GROUP BY t.charge_country
            ORDER BY total_revenue DESC
            LIMIT 5
        """

        result = duckdb.query(query).to_df()
        result['total_revenue'] = result['total_revenue'].round(2)
         
        fig = px.pie(
            result,
            values='total_revenue',
            names='country',
            title='Top 5 Best Countries by Revenue',
            labels={'country': 'Country', 'total_revenue': 'Total Revenue ($)'},
            color='country',
            color_discrete_sequence=['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'],
        )
        
        # Format the text on pie slices to show percentage and currency
        fig.update_traces(
            texttemplate='%{label}<br>%{percent}<br>$%{value:,.0f}',
            textposition='inside',
            textfont_size=12
        )
        
        return fig
    
    def _best_countries_by_customers_plot(self, dataManager):
        """Generate Best Countries by number of customers plot."""
        transactions = dataManager.transactions

        query = """
            SELECT 
                t.charge_country AS country,
                COUNT(DISTINCT t.user_email) AS customer_count
            FROM transactions t
            GROUP BY t.charge_country
            ORDER BY customer_count DESC
            LIMIT 5
        """

        result = duckdb.query(query).to_df()
        result['customer_count'] = result['customer_count'].round(2)

        fig = px.bar(
            result,
            x='country',
            y='customer_count',
            title='Top 5 Countries by Number of Customers',
            labels={'country': 'Country', 'customer_count': 'Number of Customers'},
            color='country',
            text='customer_count',
            color_discrete_sequence=['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'],
        )

        # Format text on bars
        fig.update_traces(texttemplate='%{text:,.0f}', textposition='outside')

        return fig
    
    def _best_selling_products_plot(self, dataManager):
        """Generate Best Selling Products by number of purchases plot."""
        transactions = dataManager.transactions
        products = dataManager.products

        query = """
            SELECT 
                p.product_id,
                p.description AS product_description,
                COUNT(t.transaction_id) AS purchase_count
            FROM transactions t
            INNER JOIN products p ON t.product_id = p.product_id
            GROUP BY p.product_id, p.description
            ORDER BY purchase_count DESC
            LIMIT 5
        """

        result = duckdb.query(query).to_df()
        result['product_id'] = result['product_id'].map(lambda x: f'Product {int(x)}')
        result['purchase_count'] = result['purchase_count'].round(2)

        fig = px.bar(
            result,
            x='product_id',
            y='purchase_count',
            title='Top 5 Best Selling Products by Number of Purchases',
            labels={'product_id': 'Product', 'purchase_count': 'Number of Purchases', 'product_description': 'Description'},
            text='purchase_count',
            color='product_id',
            color_discrete_sequence=['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'],
            hover_data=['product_description']
        )

        # Format text on bars
        fig.update_traces(texttemplate='%{text:,.0f}', textposition='outside')

        return fig

    def _best_users_by_revenue_plot(self, dataManager):
        """Generate Best Users by Revenue plot."""
        leads = dataManager.leads
        leads_scored = dataManager.leads_scored
        transactions = dataManager.transactions
        products = dataManager.products

        query = """
            SELECT 
                l.user_email AS user_name,
                SUM(p.suggested_price) AS total_revenue
            FROM leads_scored l
            LEFT JOIN transactions t ON l.user_email = t.user_email
            LEFT JOIN products p ON t.product_id = p.product_id
            GROUP BY l.user_email
            ORDER BY total_revenue DESC
            LIMIT 5
        """

        result = duckdb.query(query).to_df()
        result['total_revenue'] = result['total_revenue'].round(2)
         
        fig = px.bar(
            result,
            x='user_name',
            y='total_revenue',
            title='Top 5 Best Users by Revenue',
            labels={'user_name': 'User Name', 'total_revenue': 'Total Revenue ($)'},
            color='user_name',
            text='total_revenue'
        )
        
        # Format text on bars to show currency
        fig.update_traces(texttemplate='$%{text:,.0f}', textposition='outside')
        
        return fig
    
    def _best_users_by_purchases_plot(self, dataManager):
        """Generate Best Users by Number of Purchases plot."""
        leads = dataManager.leads
        leads_scored = dataManager.leads_scored
        transactions = dataManager.transactions
        products = dataManager.products

        query = """
            SELECT 
                l.user_email,
                COUNT(t.transaction_id) AS purchase_count
            FROM leads_scored l
            LEFT JOIN transactions t ON l.user_email = t.user_email
            LEFT JOIN products p ON t.product_id = p.product_id
            GROUP BY l.user_email
            ORDER BY purchase_count DESC
            LIMIT 5
        """

        result = duckdb.query(query).to_df()
        result['purchase_count'] = result['purchase_count'].round(2)
         
        fig = px.bar(
            result,
            x='user_email',
            y='purchase_count',
            title='Top 5 Best Users by Number of Purchases',
            labels={'user_email': 'User Email', 'purchase_count': 'Number of Purchases'},
            color='user_email',
            text='purchase_count'
        )
        
        # Format text on bars
        fig.update_traces(texttemplate='%{text:,.0f}', textposition='outside')
        
        return fig
    
    def _correlation_heatmap_plot(self, dataManager):
        """Generate Correlation Heatmap plot."""
        leads_scored = dataManager.leads_scored

        query = """
            SELECT
                l.p1,
                l.member_rating,
                l.purchase_frequency
            FROM leads_scored l
        """

        df_analysis = duckdb.query(query).to_df() 
        corr_matrix = df_analysis.corr()

        fig = px.imshow(
            corr_matrix,
            text_auto=True,
            title='Correlation Heatmap of Key Metrics',
            x=df_analysis.columns,
            y=df_analysis.columns,
            color_continuous_scale='RdBu_r',
            zmin=-1,
            zmax=1
        )

        return fig
    
    def _price_vs_purchase_count_plot(self, dataManager):
        """Generate Price vs. Purchase Count plot."""
        transactions = dataManager.transactions
        products = dataManager.products

        query = """
            SELECT 
                p.suggested_price,
                COUNT(t.transaction_id) AS purchase_count
            FROM transactions t
            INNER JOIN products p ON t.product_id = p.product_id
            GROUP BY p.suggested_price
        """

        result = duckdb.query(query).to_df()

        fig = px.scatter(
            result,
            x='suggested_price',
            y='purchase_count',
            title='Price vs. Purchase Count',
            labels={'suggested_price': 'Suggested Price ($)', 'purchase_count': 'Number of Purchases'},
            trendline='ols',
            color_discrete_sequence=['#FF6B6B']
        )

        return fig
    
    def _email_provider_plot(self, dataManager):
        """Generate Email Provider Distribution plot."""
        leads = dataManager.leads

        query = """
            SELECT 
                email_provider,
                COUNT(*) AS customer_count
            FROM leads
            GROUP BY email_provider
            ORDER BY customer_count DESC
            LIMIT 5
        """

        result = duckdb.query(query).to_df()
        fig = px.bar(
            result,
            x='email_provider',
            y='customer_count',
            title='Top 5 Email Providers by Number of Customers',
            labels={'email_provider': 'Email Provider', 'customer_count': 'Number of Customers'},
            color='email_provider',
            text='customer_count',
            color_discrete_sequence=['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'],
        )

        # Format text on bars
        fig.update_traces(texttemplate='%{text:,.0f}', textposition='outside')

        return fig
    
    def _member_rating_distribution_plot(self, dataManager):
        """Generate Member Rating Distribution plot."""
        leads_scored = dataManager.leads_scored

        query = """
            SELECT 
                member_rating,
                COUNT(*) AS customer_count
            FROM leads_scored
            GROUP BY member_rating
            ORDER BY member_rating
        """

        result = duckdb.query(query).to_df()
        fig = px.bar(
            result,
            x='member_rating',
            y='customer_count',
            title='Member Rating Distribution',
            labels={'member_rating': 'Member Rating', 'customer_count': 'Number of Customers'},
            color='member_rating',
            text='customer_count',
            color_continuous_scale=px.colors.sequential.Viridis
        )

        # Format text on bars
        fig.update_traces(texttemplate='%{text:,.0f}', textposition='outside')

        return fig
    

if __name__ == "__main__":
    plot_generator = PlotGenerator()
    from data_manager import DataManager
    data_manager = DataManager()
    data_manager.load_data()
    plot_generator.generate_plots(data_manager)
    #plot_generator._segment_analysis_plot(data_manager)
    #plot_generator._segment_distribution_plot(data_manager)
    #plot_generator._revenue_by_segment_plot(data_manager)
    #plot_generator._best_selling_products_plot(data_manager)
    #plot_generator._best_countries_by_revenue_plot(data_manager)