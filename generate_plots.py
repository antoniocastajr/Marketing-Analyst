# PROJECT: Data Analyst Agent
# AUTHOR: Antonio Castañares Rodríguez
# -----------------------

# DESCRIPTION: This file generates and saves relevant visualizations available for our Marketing Analyst.

import os 
import logging
import duckdb
import plotly.express as px

# --------------------------------------LOGGING--------------------------------------------
# Logging configuration (print time, name, level and message using the terminal)
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# Suppress the httpx library logs to avoid cluttering the output
logging.getLogger("httpx").setLevel(logging.WARNING)
LOGGER = logging.getLogger(__name__)

# --------------------------------------PLOT GENERATOR CLASS---------------------------------

class PlotGenerator:
    """Generates and saves plots for marketing analysis."""

    _instance = None
    _plots = [
             {
                "title": "Customer Segment Analysis",
                "description": "Bar plot that visualizes customer segments based on key metrics.",
                "path": "plots/segment_analysis.json"
             },{
                 'title': 'Customer Segment Distribution',
                 'description': 'Pie chart showing the distribution of customers across different segments.',
                 'path': 'plots/segment_distribution.json'
             },{
                 'title': 'Revenue by Customer Segment',
                 'description': 'Bar chart displaying revenue generated by each customer segment.',
                 'path': 'plots/revenue_by_segment.json'
             },{
                 'title': 'Best Selling Products by Revenue',
                 'description': 'Bar chart highlighting the top-selling products in the dataset by revenue.',
                 'path': 'plots/best_selling_products.json'
             },{
                 'title': 'Best Countries by Revenue',
                 'description': 'Bar chart showing the top countries by revenue.',
                 'path': 'plots/best_countries_by_revenue.json'
             }
    ]

    def __new__(cls):
        """Ensure only one instance of PlotGenerator exists."""
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def get_plots(self) -> list:
        """Public method to get all plots metadata."""
        return self._plots.copy()
    
    def get_available_plots(self) -> list:
        """Get list of plots that exist on disk.
        
        Returns:
            list: Plots with their metadata that have been generated.
        """
        available = []
        for plot in self._plots:
            if os.path.exists(plot['path']):
                plot_info = plot.copy()
                plot_info['available'] = True
                available.append(plot_info)
        return available
    
    def get_plot_by_title(self, title: str) -> dict:
        """Get a specific plot by its title.
        
        Args:
            title: The title of the plot to retrieve.
            
        Returns:
            dict: Plot metadata or None if not found.
        """
        for plot in self._plots:
            if plot['title'] == title:
                return plot.copy()
        return None
    
    def check_plot_exist(self, path) -> bool:
        """Check if a specific plot exists."""
        if not os.path.exists(path):
            return False
        return True

    def generate_plots(self,dataManager):
        """Generate and save all plots."""
        # Create plots directory if it doesn't exist
        os.makedirs('plots', exist_ok=True)

        for plot in self._plots:
            # Generate each plot based on its title or description
            if plot['title'] == "Customer Segment Analysis" and not self.check_plot_exist(plot['path']):
                fig = self._segment_analysis_plot(dataManager)
            elif plot['title'] == "Customer Segment Distribution" and not self.check_plot_exist(plot['path']):
                fig = self._segment_distribution_plot(dataManager)
            elif plot['title'] == "Revenue by Customer Segment" and not self.check_plot_exist(plot['path']):
                fig = self._revenue_by_segment_plot(dataManager)
            elif plot['title'] == "Best Selling Products by Revenue" and not self.check_plot_exist(plot['path']):
                fig = self._best_selling_products_plot(dataManager)
            elif plot['title'] == "Best Countries by Revenue" and not self.check_plot_exist(plot['path']):
                fig = self._best_countries_by_revenue_plot(dataManager)
            else:
                continue
            
            # Save the plot to the specified path
            # Save to file
            try:
                with open(plot['path'], 'w') as f:
                    f.write(fig.to_json())
            except Exception as e:
                print(f"Error saving plot: {e}")
        
    def _segment_analysis_plot(self, dataManager):
        """Generate Customer Segment Analysis plot."""
    
        try:
            leads_scored = dataManager.leads
            transactions = dataManager.transactions
            # Select only needed columns for analysis
            leads_scored = leads_scored[['user_email', 'p1', 'member_rating', 'customer_segment']]
            transactions = transactions[['user_email', 'purchased_at']]
        except Exception as e:
            LOGGER.error(f"Error loading data: {e}")
            raise

        # Calculate transaction_frequency (group by user_email and count transactions)
        purchase_frequency = transactions.groupby('user_email').size().reset_index(name='purchase_frequency')
        LOGGER.info(f"Transaction frequency calculated. Mean frequency: {purchase_frequency['purchase_frequency'].mean():.2f}")

        # Combines customer profiles with their purchase activity, keeping all customers even if they never purchased anything.
        df_analysis = leads_scored.merge(purchase_frequency, on='user_email', how='left')
        LOGGER.info(f"Features merged. Customer data shape: {df_analysis.shape}")

        # Fill missing values
        df_analysis['purchase_frequency'] = df_analysis['purchase_frequency'].fillna(0)

        # Create summary statistics for each customer segment and rename user_email to customer_count
        df_summary = df_analysis.groupby('customer_segment').agg({
            'p1': 'mean',                                                                                                           # Use mean for lead score                        
            'member_rating': 'mean',                                                                                                # Use mean for member rating                                                         
            'purchase_frequency': 'mean',                                                                                           # Use mean for purchase frequency      
            'user_email': 'count'                                                                                                   # Count customers in each segment   
        }).rename(columns={'user_email': 'customer_count'}).reset_index()

        # Round statistics for better readability
        df_summary['avg_p1'] = df_summary['p1'].round(3)
        df_summary['avg_member_rating'] = df_summary['member_rating'].round(2)
        df_summary['avg_purchase_frequency'] = df_summary['purchase_frequency'].round(2)

        # Define segment labels
        segment_labels = {
            '0': 'Segment 0',                # Low engagement
            '1': 'Segment 1',                # Occasional engagement
            '2': 'Segment 2',                # Regular engagement
            '3': 'Segment 3',                # Strong engagement
            '4': 'Segment 4'                 # Maximum engagement
        }
            
        # Apply segment labels to the summary DataFrame
        df_summary['segment_name'] = df_summary['customer_segment'].astype(str).map(segment_labels).fillna(df_summary['customer_segment'].astype(str))

        # Create Plotly bar chart
        df_viz = df_summary.melt(id_vars=['segment_name'],
                                value_vars=['avg_p1', 'avg_member_rating', 'avg_purchase_frequency'],
                                var_name='Metric',
                                value_name='Value')
        
        fig = px.bar(
            df_viz,
            x='segment_name',
            y='Value',
            color='Metric',
            barmode='group',
            title='Segment Analysis: Lead Score, Member Rating, Purchase Frequency',
            labels={'segment_name': 'Customer Segment', 'Value': 'Average Value', 'Metric': 'Metric'}
        )

        return fig

    def _segment_distribution_plot(self, dataManager):  
        """Generate Customer Segment Distribution plot."""
        leads_scored = dataManager.leads

        query = """
            SELECT 
                customer_segment,
                COUNT(*) AS customer_count
            FROM leads_scored
            GROUP BY customer_segment
        """

        result = duckdb.query(query).to_df()
        result['customer_segment'] = result['customer_segment'].map(lambda x: f'Segment {x}')
        fig = px.pie(
            result,
            names='customer_segment',
            values='customer_count',
            title='Customer Segment Distribution',
            labels={'customer_segment': 'Customer Segment', 'customer_count': 'Number of Customers'},
            color='customer_segment',
            color_discrete_sequence=[ '#FFA07A','#FF6B6B','#4ECDC4','#45B7D1','#98D8C8','#FF6B6B' ]
        )

        # Format the text on pie slices to show percentage and currency
        fig.update_traces(
            texttemplate='%{label}<br>%{percent}<br>$%{value:,.0f}',
            textposition='inside',
            textfont_size=12
        )
        
        return fig

    def _revenue_by_segment_plot(self, dataManager):
        """Generate Revenue by Customer Segment plot."""
        leads_scored = dataManager.leads
        transactions = dataManager.transactions
        products = dataManager.products

        query = """
            SELECT 
                l.customer_segment,
                SUM(p.suggested_price) AS total_revenue
            FROM leads_scored l
            LEFT JOIN transactions t ON l.user_email = t.user_email
            LEFT JOIN products p ON t.product_id = p.product_id
            GROUP BY l.customer_segment
            ORDER BY l.customer_segment
        """

        result = duckdb.query(query).to_df()
        result['customer_segment'] = result['customer_segment'].map(lambda x: f'Segment {x}')
         
        fig = px.bar(
            result,
            x='customer_segment',
            y='total_revenue',
            title='Revenue by Customer Segment',
            labels={'customer_segment': 'Customer Segment', 'total_revenue': 'Total Revenue ($)'},
            color='customer_segment',
            color_discrete_sequence=['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'],
            text='total_revenue'
        )
        
        # Format the text on bars to show currency
        fig.update_traces(texttemplate='$%{text:,.0f}', textposition='outside')
        
        return fig

    def _best_selling_products_plot(self, dataManager):
        """Generate Best Selling Products by Revenue plot."""
        transactions = dataManager.transactions
        products = dataManager.products

        query = """
            SELECT 
                p.product_id,
                p.description AS product_description,
                SUM(p.suggested_price) AS total_revenue
            FROM transactions t
            INNER JOIN products p ON t.product_id = p.product_id
            GROUP BY p.product_id, p.description
            ORDER BY total_revenue DESC
            LIMIT 5
        """

        result = duckdb.query(query).to_df()
        result['product_id'] = result['product_id'].map(lambda x: f'Product {int(x)}')
        result['total_revenue'] = result['total_revenue'].round(2)

        fig = px.bar(
            result,
            x='product_id',
            y='total_revenue',
            title='Top 5 Best Selling Products by Revenue',
            labels={'product_id': 'Product', 'total_revenue': 'Total Revenue ($)', 'product_description': 'Description'},
            text='total_revenue',
            color='product_id',  
            color_discrete_sequence=['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'],
            hover_data=['product_description']  # Show description on hover
        )
        
        # Format text on bars
        fig.update_traces(texttemplate='$%{text:,.0f}', textposition='outside')
        
        return fig

    def _best_countries_by_revenue_plot(self, dataManager):
        """Generate Best Countries by Revenue plot."""
        leads = dataManager.leads
        transactions = dataManager.transactions
        products = dataManager.products

        query = """
            SELECT 
                t.charge_country AS country,
                SUM(p.suggested_price) AS total_revenue
            FROM transactions t
            INNER JOIN products p ON t.product_id = p.product_id
            GROUP BY t.charge_country
            ORDER BY total_revenue DESC
            LIMIT 5
        """

        result = duckdb.query(query).to_df()
        result['total_revenue'] = result['total_revenue'].round(2)
         
        fig = px.pie(
            result,
            values='total_revenue',
            names='country',
            title='Top 5 Best Countries by Revenue',
            labels={'country': 'Country', 'total_revenue': 'Total Revenue ($)'},
            color='country',
            color_discrete_sequence=['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8'],
        )
        
        # Format the text on pie slices to show percentage and currency
        fig.update_traces(
            texttemplate='%{label}<br>%{percent}<br>$%{value:,.0f}',
            textposition='inside',
            textfont_size=12
        )
        
        return fig

if __name__ == "__main__":
    plot_generator = PlotGenerator()
    from data_manager import DataManager
    data_manager = DataManager()
    data_manager.load_data()
    plot_generator._generate_plots(data_manager)
    #plot_generator._segment_analysis_plot(data_manager)
    #plot_generator._segment_distribution_plot(data_manager)
    #plot_generator._revenue_by_segment_plot(data_manager)
    #plot_generator._best_selling_products_plot(data_manager)
    #plot_generator._best_countries_by_revenue_plot(data_manager)